#include "port.h" //added for platform specific stuff - mlt
#include <string.h>
#include "FonixTtsDtSimple_casio.h"

#ifdef MICRODECTALK
#include "epsonapi.h"
#else
#include "simpleapi.h"
#endif

#ifdef OS_SYMBIAN
#include "DTSymbianThreading.h"
#endif

#ifndef OS_SYMBIAN
#ifdef AD_VDSP
section("INTERNAL_DATA") volatile FTTSDTUDATA_T gDECtalkUserData;
#else
volatile FTTSDTUDATA_T gDECtalkUserData;
#endif
#ifdef NO_INITALIZED_GLOBALS
volatile FTTSDTUDATA_T *gpDECtalkUserData;  
#else
volatile FTTSDTUDATA_T *gpDECtalkUserData = NULL;
#endif //NO_INITIALIZED_GLOBALS
#else
short *FnxTTSDTSimpleCollectCallback(short *output_buf,long error, void* pUserData);
void SetGlobalData(GlobalDTPtr data);
#endif //OS_SYMBIAN

void TextToSpeechSetDictPath(char* pDictPath);
void TextToSpeechSetTablePath(char* pTablePath);
extern void CleanupMemory();

#if defined(__cplusplus)
extern "C" {
#endif
/*******************************************************************************
int FnxTTSDtSimpleCallback(short *output_buf,long error)
intilizes the TTS
Accepts a pointer to a array of 'short' and a 'long' error / status flag
     (size is 71 for 11Khz samplerate or 51 for 8Khz)
Returns a pointer to a buffer of shorts to receive the next data generated by 
the engine.  Returning a NULL for the buffer aborts the current synthesis 
operation
*******************************************************************************/
#ifdef AD_VDSP
section("INTERNAL_PROGRAM") short *FnxTTSDtSimpleCallback(short *output_buf,long error)
#elif !defined(OS_SYMBIAN)
short *FnxTTSDtSimpleCallback(short *output_buf,long error)
#else
short *FnxTTSDtSimpleCallback(short *output_buf,long error, void* pUserData)
#endif
{
  int reqLength = 0;
#ifdef OS_SYMBIAN
  GlobalDTPtr vgp = GetGlobalDTPtr();
  FTTSDTUDATA_T* gpDECtalkUserData = vgp->gpDECtalkUserData;
#endif

  switch (error)
  {
  	case 0:
	  // Calculate the required buffer length to contain the next buffer
		if (gpDECtalkUserData->gDECtalkFlags > 2)
		  return(NULL);

#ifdef MICRODECTALK
		if( !gpDECtalkUserData->gDECtalkOverflow )
		{
#ifdef SUPPORT_ULAW
			memcpy( (char *)((char *)gpDECtalkUserData->gDECtalkBufPtr + gpDECtalkUserData->gDECtalkBufPos), output_buf, gpDECtalkUserData->gDECtalkPktSize[gpDECtalkUserData->gDECtalkFlags] * sizeof(unsigned char) );
#else
			memcpy( (char *)(gpDECtalkUserData->gDECtalkBufPtr + gpDECtalkUserData->gDECtalkBufPos), output_buf, gpDECtalkUserData->gDECtalkPktSize[gpDECtalkUserData->gDECtalkFlags] * sizeof(short) );
#endif
		}
#endif
		// Increment the buffer position pointer
		gpDECtalkUserData->gDECtalkBufPos += 
			gpDECtalkUserData->gDECtalkPktSize[gpDECtalkUserData->gDECtalkFlags];
			
#if 0
	   // Dump the buffer to the screen for debug 
		int i;
		unsigned long j;
		for (i=0;i<71;i++)
		{
			j=output_buf[i];
			if (i && i%8==0)
			{
				FNX_PRINTF("\n");
			}
			FNX_PRINTF("0x%04X ",j&0xFFFF);
		}
		FNX_PRINTF("\n");
#endif
	
		// See if the buffer has enough room for the next buffer
		reqLength = gpDECtalkUserData->gDECtalkBufPos + gpDECtalkUserData->gDECtalkPktSize[gpDECtalkUserData->gDECtalkFlags];
		if (reqLength > gpDECtalkUserData->gDECtalkBufSize)
		  {
			 // If not, Indicate it and use the dummy buffer
			 gpDECtalkUserData->gDECtalkOverflow = 1;
			 return((short *)gpDECtalkUserData->gDECtalkDmyBuffer);
		  }
	
		return((short *)(gpDECtalkUserData->gDECtalkBufPtr + gpDECtalkUserData->gDECtalkBufPos));
		break;
	case 3:
		gpDECtalkUserData->gDECtalkLastIndex[0] = (short)*(output_buf);
		gpDECtalkUserData->gDECtalkLastIndex[1] = (short)*(output_buf+1);
		return((short *)(gpDECtalkUserData->gDECtalkBufPtr + gpDECtalkUserData->gDECtalkBufPos));
		break;
	default:
		return (NULL);
		break;
  }
	
}

/*******************************************************************************
int FnxTTSDtSimpleOpen(short *(*callback)(short *,long),void * user_dict)
initializes the TTS
Accepts a 'callback' function, a user dictionary, a dictionary and table as input
  The callback function is called by the engine whenever there is output data
  (either audio data or index marks) for the user to handle.
  If a NULL is passed in for this callback function, the API uses an internal
  callback function.
Returns the completion/error status flag
*******************************************************************************/
#if !defined(OS_SYMBIAN)
int FnxTTSDtSimpleOpen(short *(*callback)(short *,long),void *user_dict)
#else
int FnxTTSDtSimpleOpen(short *(*callback)(short *,long, void*),void *user_dict, void* user_data)
#endif
{
	int retval = -1;
#ifdef OS_SYMBIAN
	GlobalDTPtr vgp = GetGlobalDTPtr();
	FTTSDTUDATA_T* gpDECtalkUserData = (FTTSDTUDATA_T*)calloc(1, sizeof(FTTSDTUDATA_T));
	vgp->gpDECtalkUserData = gpDECtalkUserData;
#else
	gpDECtalkUserData = &gDECtalkUserData;
#endif
	
	gpDECtalkUserData->gDECtalkStatus = DT_IN_USE;

//  if(( !gpDECtalkUserData->gDECtalkInit ) || (gpDECtalkUserData->gDECtalkUserDict != user_dict))
//	 {
		gpDECtalkUserData->gDECtalkPktSize[0] = gpDECtalkUserData->gDECtalkPktSize[1] = 71;
		gpDECtalkUserData->gDECtalkPktSize[2] = 51;
		gpDECtalkUserData->gDECtalkBufPos = 0;
		gpDECtalkUserData->gDECtalkBufPtr = NULL;
		gpDECtalkUserData->gDECtalkUserDict = user_dict;
		gpDECtalkUserData->gDECtalkLastIndex[0] = 0;
		gpDECtalkUserData->gDECtalkLastIndex[1] = 0;

		if (callback == NULL)
		{
#ifndef OS_SYMBIAN
			retval = TextToSpeechInit(FnxTTSDtSimpleCallback,user_dict);
#else
			retval = TextToSpeechInit(FnxTTSDtSimpleCallback,user_dict, user_data);
#endif
			gpDECtalkUserData->gDECtalkUserCallback = 0;
		}
		else
		{
#ifndef OS_SYMBIAN
			retval = TextToSpeechInit(callback,user_dict);
#else
			vgp->simpleData.g_usercallback = callback;
			retval = TextToSpeechInit(FnxTTSDTSimpleCollectCallback,user_dict, user_data);
#endif
			gpDECtalkUserData->gDECtalkUserCallback = 1;
		}

		gpDECtalkUserData->gDECtalkVoiceID = 0;
		if( !retval )
			gpDECtalkUserData->gDECtalkInit = 1;
		else
			gpDECtalkUserData->gDECtalkInit = 0;

//	 }
	gpDECtalkUserData->gDECtalkStatus = DT_AVAILABLE;
	return(retval);
}

/*******************************************************************************
void FnxTTSDtSimpleClose()
closes the TTS core
*******************************************************************************/
void FnxTTSDtSimpleClose()
{
#ifdef OS_SYMBIAN
	GlobalDTPtr vgp = GetGlobalDTPtr();
	FTTSDTUDATA_T* gpDECtalkUserData = vgp->gpDECtalkUserData;
#endif
	gpDECtalkUserData->gDECtalkStatus = DT_IN_USE;

// loading the dictionary from an external file uses mallocs
// and USE_NAND closes the dictionary
// so !DICT_IN_MEMORY requires cleanup
#if !defined DICT_IN_MEMORY
	if(gpDECtalkUserData && gpDECtalkUserData->gDECtalkInit)
		TextToSpeechUnloadDictionary();

//#ifdef ALLOC_MEMORY
	// calling this now because of the memory leaks in pDph_t->speaker_rom_ptr
	// will eventually only be called for ALLOC_MEMORY
	CleanupMemory();
//#endif
#else
	TextToSpeechReset( FULL_ENGINE_RESET );
#endif //DICT_IN_MEMORY

#ifndef OS_SYMBIAN
	gpDECtalkUserData->gDECtalkStatus = DT_AVAILABLE;
	gpDECtalkUserData = NULL;
#endif
	return;
}

/*******************************************************************************
long FnxTTSDtSimpleStart(char *String,short *buffer,int buflength,int flags )
creates raw audio output and stores it in the supplied buffer for the input string
Accepts an input string, buffer, length, and format flag as input
Returns the number of samples or a negative value for error status
If the synthesized wave is larger than the buffer, only that portion
which will fit in the buffer is returned and the buffer length required is
returned as a negative number of samples.

*******************************************************************************/
long FnxTTSDtSimpleStart(char *String, short *buffer,long buflength,int flags )
{
	long retval = 0;
#ifdef OS_SYMBIAN
	GlobalDTPtr vgp = GetGlobalDTPtr();
	FTTSDTUDATA_T* gpDECtalkUserData = vgp->gpDECtalkUserData;
	if(flags & OUTPUT_QUEUE)
	{
		flags = flags ^ OUTPUT_QUEUE;
		vgp->bOutput_queue = 1;
	}
	else if(flags & OUTPUT_STREAMING)
	{
		flags = flags ^ OUTPUT_STREAMING;
		vgp->bOutput_queue = 0;
	}
#endif

	if(!gpDECtalkUserData || !gpDECtalkUserData->gDECtalkInit || gpDECtalkUserData->gDECtalkStatus == DT_IN_USE)
		return(1);

	if (flags < 1 || flags > 2)
		return(1);

	gpDECtalkUserData->gDECtalkStatus = DT_IN_USE;

#ifdef MICRODECTALK
	if( !gpDECtalkUserData->gDECtalkUserCallback )
	{
		if (buflength < gpDECtalkUserData->gDECtalkPktSize[flags])
			return(1);
		if( !buffer )
			return(1);
	}
#else
#ifdef OS_SYMBIAN // don't check buflength if going to a queue
	if (!vgp->bOutput_queue && (buflength < gpDECtalkUserData->gDECtalkPktSize[flags]))
		return(1);
	else if(vgp->bOutput_queue && !vgp->queueStruct.bFinished) 
	{
		// we must be in the middle of synthesizing, so don't start another thread.
		return(1);
	}
#endif
	if (buflength < gpDECtalkUserData->gDECtalkPktSize[flags])
		return(1);

#endif
	gpDECtalkUserData->gDECtalkBufSize = buflength;
	gpDECtalkUserData->gDECtalkBufPos = 0;
	gpDECtalkUserData->gDECtalkBufPtr = buffer;
	gpDECtalkUserData->gDECtalkFlags = flags;
	gpDECtalkUserData->gDECtalkOverflow = 0;

#ifdef OS_SYMBIAN
	if(vgp->bOutput_queue) // if we're going to a queue, allocate the first buffer
	{
		gpDECtalkUserData->gDECtalkBufPtr = (short*)calloc(1, sizeof(short)*gpDECtalkUserData->gDECtalkPktSize[flags]);
		vgp->queueStruct.bufSize = gpDECtalkUserData->gDECtalkBufSize;
		//ResetQueue();
	}
#endif

#ifdef MICRODECTALK
	retval = TextToSpeechStart( String );
#elif defined (OS_SYMBIAN)
	if(vgp->bOutput_queue)
	{
		//retval = TextToSpeechStart( String , (short *)gpDECtalkUserData->gDECtalkBufPtr, gpDECtalkUserData->gDECtalkFlags);	
	// start thread with data?
		StartThread(String);
	}
	else
		retval = TextToSpeechStart( String , (short *)gpDECtalkUserData->gDECtalkBufPtr, gpDECtalkUserData->gDECtalkFlags);
#else

	retval = TextToSpeechStart( String , (short *)gpDECtalkUserData->gDECtalkBufPtr, gpDECtalkUserData->gDECtalkFlags);

#endif
	gpDECtalkUserData->gDECtalkStatus = DT_AVAILABLE;

	if (retval != 0)
		return(retval);
	return ((gpDECtalkUserData->gDECtalkOverflow == 1) ? (0 - gpDECtalkUserData->gDECtalkBufPos) : gpDECtalkUserData->gDECtalkBufPos);
/*******************************************************************************
long FnxTTSDtSimpleStartW(wchar_t *String,short *buffer,int buflength,int flags,int iInType )
creates raw audio output and stores it in the supplied buffer for the input string
Accepts an input string, buffer, length, and format flag and input format flag(unicode etc.)as input
Returns the number of samples or a negative value for error status
If the synthesized wave is larger than the buffer, only that portion
which will fit in the buffer is returned and the buffer length required is
returned as a negative number of samples.

*******************************************************************************/
#if defined CASIO_SH3 && defined _BIGENDIAN_
long FnxTTSDtSimpleStartW(wchar_t *String, short *buffer,long buflength,int flags,int iInType, char *dictname,char *tablename)
#else
long FnxTTSDtSimpleStartW(wchar_t *String, short *buffer,long buflength,int flags,int iInType )
#endif
{
	long ret_val;
	char sText[(MAX_CHARS_TO_CONVERT*5)+1];
	
	ret_val = TextToSpeechConvertInput(String, iInType, sText, (MAX_CHARS_TO_CONVERT*5));
	
	if(ret_val)
	{
		return(ret_val);
	}
	else
	{
#if defined CASIO_SH3 && defined _BIGENDIAN_
		ret_val = FnxTTSDtSimpleStart(sText, buffer,buflength,flags,dictname,tablename);
#else
		ret_val = FnxTTSDtSimpleStart(sText, buffer,buflength,flags);
#endif
	}
	
	return(ret_val);
	
}
/*******************************************************************************
long FnxTTSDtSimpleStartX(void *String,short *buffer,int buflength,int flags,int iInType )
creates raw audio output and stores it in the supplied buffer for the input string
Accepts an input string, buffer, length, and format flag and input format flag(unicode,ascii etc.)as input
Returns the number of samples or a negative value for error status
If the synthesized wave is larger than the buffer, only that portion
which will fit in the buffer is returned and the buffer length required is
returned as a negative number of samples.

*******************************************************************************/
#if defined CASIO_SH3 && defined _BIGENDIAN_
long FnxTTSDtSimpleStartX(void *String, short *buffer,long buflength,int flags,int iInType, char *dictname,char *tablename )
#else
long FnxTTSDtSimpleStartX(void *String, short *buffer,long buflength,int flags,int iInType )
#endif
{
	long retval;
	switch(iInType)
	{
	case 0:
	case 1:
	case 2:
	case 3:
	case 4:
#if defined CASIO_SH3 && defined _BIGENDIAN_
	retval = FnxTTSDtSimpleStartW((wchar_t *)String,buffer,buflength,flags,iInType,dictname,tablename );
#else
	retval = FnxTTSDtSimpleStartW((wchar_t *)String,buffer,buflength,flags,iInType );
#endif
			break;
	case 5:
#if defined CASIO_SH3 && defined _BIGENDIAN_
	retval = FnxTTSDtSimpleStart((char *)String, buffer,buflength,flags,dictname,tablename);
#else
	retval = FnxTTSDtSimpleStart((char *)String, buffer,buflength,flags);
#endif
			break;
	}
	return(retval);

}

/*******************************************************************************
void FnxTTSDtSimpleChangeVoice(FnxDECtalkVoiceId NewVoice, int flags)
creates audio output and plays for the input string
*******************************************************************************/
void FnxTTSDtSimpleChangeVoice( FnxDECtalkVoiceId NewVoice ,int flags )
{
	char Name[18] = "\0";
	int ret_val = 0;
	short NameBuf[213];
#ifdef OS_SYMBIAN
	GlobalDTPtr vgp = GetGlobalDTPtr();
	FTTSDTUDATA_T* gpDECtalkUserData = vgp->gpDECtalkUserData;
#endif

	if(!gpDECtalkUserData || !gpDECtalkUserData->gDECtalkInit || gpDECtalkUserData->gDECtalkStatus == DT_IN_USE)
		return;

	gpDECtalkUserData->gDECtalkStatus = DT_IN_USE;
	gpDECtalkUserData->gDECtalkFlags = flags;

	switch(NewVoice)
	{
		case Harry:
		{
#ifdef MICRODECTALK
			FNX_STRCPY(Name, "nh");		/*harry*/
#else
			FNX_STRCPY(Name, "[:name harry]");		/*harry*/
#endif
			break;
		}
		case Frank:
		{
#ifdef MICRODECTALK
			FNX_STRCPY(Name, "nf");		/*frank*/
#else
			FNX_STRCPY(Name, "[:name frank]");		/*frank*/
#endif
			break;
		}
		case Dennis:
		{
#ifdef MICRODECTALK
			FNX_STRCPY(Name, "nd");		/*dennis*/
#else
			FNX_STRCPY(Name, "[:name dennis]");		/*dennis*/
#endif
			break;
		}
		case Kit:
		{
#ifdef MICRODECTALK
			FNX_STRCPY(Name, "nk");		/*kit*/
#else
			FNX_STRCPY(Name, "[:name kit]");		/*kit*/
#endif
			break;
		}
		case Betty:
		{
#ifdef MICRODECTALK
			FNX_STRCPY(Name, "nb");		/*betty*/
#else
			FNX_STRCPY(Name, "[:name betty]");		/*betty*/
#endif
			break;
		}
		case Ursula:
		{
#ifdef MICRODECTALK
			FNX_STRCPY(Name, "nu");		/*ursula*/
#else
			FNX_STRCPY(Name, "[:name ursula]");		/*ursula*/
#endif
			break;
		}
		case Rita:
		{
#ifdef MICRODECTALK
			FNX_STRCPY(Name, "nr");		/*rita*/
#else
			FNX_STRCPY(Name, "[:name rita]");		/*rita*/
#endif
			break;
		}
		case Wendy:
		{
#ifdef MICRODECTALK
			FNX_STRCPY(Name, "nw");		/*wendy*/
#else
			FNX_STRCPY(Name, "[:name wendy]");		/*wendy*/
#endif
			break;
		}
		case Paul:
		default:
		{
#ifdef MICRODECTALK
			FNX_STRCPY(Name, "np");
#else
			FNX_STRCPY(Name, "[:name paul]");
#endif
			break;
		}
	}
	gpDECtalkUserData->gDECtalkStatus = DT_AVAILABLE;	//need to set here so you will go through the TextToSpeechStart
#ifdef MICRODECTALK
	TextToSpeechChangeVoice( Name );
#else
#if defined CASIO_SH3 && defined _BIGENDIAN_
	ret_val = FnxTTSDtSimpleStart(Name, NameBuf, 213, flags, gpDECtalkUserData->gDECtalkDictPath, gpDECtalkUserData->gDECtalkTablePath);
#else
	ret_val = FnxTTSDtSimpleStart(Name, NameBuf, 213, flags);
#endif
#endif
	gpDECtalkUserData->gDECtalkStatus = DT_AVAILABLE;
	gpDECtalkUserData->gDECtalkVoiceID = NewVoice;
}

/*******************************************************************************
void FnxTTSHaltSpeech()
Stops current TTS string
Returns the completion/error status flag
*******************************************************************************/
#if !defined(OS_SYMBIAN)
int FnxTTSDtSimpleHaltSpeech()
#else
int FnxTTSDtSimpleHaltSpeech(const void* threadData)
#endif
{
	int retval = 0;
#ifdef OS_SYMBIAN
	GlobalDTPtr vgp = NULL;
	FTTSDTUDATA_T* gpDECtalkUserData = NULL;

	if(threadData)
	{
		SetGlobalData((void*)threadData);
	}
	
	vgp = GetGlobalDTPtr();
	if(vgp)
	{
		gpDECtalkUserData = vgp->gpDECtalkUserData;
	}

	if(vgp && vgp->bOutput_queue)
	{
		// don't call reset if we're finished
		if(vgp->bHaltCalled || vgp->queueStruct.bFinished)
		{
			return retval;
		}
	}
#endif

	if(!gpDECtalkUserData || !gpDECtalkUserData->gDECtalkInit)
		return(1);

	retval = TextToSpeechReset( HALT_SPEECH_LEAVE_SETTINGS );

#ifdef OS_SYMBIAN
	// if we're going to a queue, we need to signal the thread so it
	// can exit gracefully
	if(vgp->bOutput_queue)
	{
		SignalThread();
		ResetQueue();
		vgp->bHaltCalled = 1;
	}
#endif
	return(retval);
}

/*******************************************************************************
void FnxTTSResetSpeech()
Resets the TTS Engine to the Default Parameters
Returns the completion/error status flag
*******************************************************************************/
int FnxTTSDtSimpleResetSpeech()
{
	int retval = 0;
#ifdef OS_SYMBIAN
	GlobalDTPtr vgp = GetGlobalDTPtr();
	FTTSDTUDATA_T* gpDECtalkUserData = vgp->gpDECtalkUserData;
#endif

	if(!gpDECtalkUserData || !gpDECtalkUserData->gDECtalkInit || gpDECtalkUserData->gDECtalkStatus == DT_IN_USE)
		return(1);

	gpDECtalkUserData->gDECtalkStatus = DT_IN_USE;

	retval = TextToSpeechReset( FULL_ENGINE_RESET );
	gpDECtalkUserData->gDECtalkStatus = DT_AVAILABLE;
	return(retval);
}

/*******************************************************************************
int FnxTTSDtSimpleSetLanguage( FnxDECtalkLanguageId LanguageID, void *user_dict,
								char *dictname,char *tablename ) 
Sets the language.
Accepts a user dictionary, dictionary and table as input
Pass NULL for user_dict, dictname or tablename if unnecessary
Most platforms will pass NULL for the the tablename
Returns the completion/error status flag - if fails language is not changed
*******************************************************************************/
int FnxTTSDtSimpleSetLanguage( FnxDECtalkLanguageId LanguageID, void *user_dict, char *dictname,char *tablename )
{
	int retval = -1;

#ifdef MULTIPLE_LANGUAGES_LOADED
#ifdef OS_SYMBIAN
	GlobalDTPtr vgp = GetGlobalDTPtr();
	FTTSDTUDATA_T* gpDECtalkUserData = vgp->gpDECtalkUserData;
#endif

	if(!gpDECtalkUserData || !gpDECtalkUserData->gDECtalkInit || gpDECtalkUserData->gDECtalkStatus == DT_IN_USE)
		return(1);

	gpDECtalkUserData->gDECtalkStatus = DT_IN_USE;
	if( LanguageID < US_English || LanguageID > Hebrew )
		return(-2);

	// call even if dictname/tablename is NULL
	TextToSpeechSetDictPath(dictname);
	TextToSpeechSetTablePath(tablename);

	if( !TextToSpeechChangeLanguage( LanguageID, user_dict ) )
	{
		gpDECtalkUserData->gDECtalkUserDict = user_dict;
		retval = 0;
	}
	else
		retval = -3;
	gpDECtalkUserData->gDECtalkStatus = DT_AVAILABLE;
#endif
	return(retval);
}

// This needs access to gpDECtalkUserData but is not exposed to the user right now
char* TextToSpeechGetDictPath()
{
#ifdef OS_SYMBIAN
	FTTSDTUDATA_T* gpDECtalkUserData = GetGlobalDTPtr()->gpDECtalkUserData;
#endif

	if(!gpDECtalkUserData)
		return NULL;
	else
		return (char*)(gpDECtalkUserData->gDECtalkDictPath);
}

char* TextToSpeechGetTablePath()
{
#ifdef OS_SYMBIAN
	FTTSDTUDATA_T* gpDECtalkUserData = GetGlobalDTPtr()->gpDECtalkUserData;
#endif

	if(!gpDECtalkUserData)
		return NULL;
	else
		return (char*)(gpDECtalkUserData->gDECtalkTablePath);
}

void TextToSpeechSetDictPath(char* pDictPath)
{
#ifdef OS_SYMBIAN
	FTTSDTUDATA_T* gpDECtalkUserData = GetGlobalDTPtr()->gpDECtalkUserData;
#else
	gpDECtalkUserData = &gDECtalkUserData;
#endif

	if(pDictPath)
	{
		FNX_STRCPY((char*)(gpDECtalkUserData->gDECtalkDictPath), pDictPath);
	}
	else
	{
		FNX_STRCPY((char*)(gpDECtalkUserData->gDECtalkDictPath), "");
	}
}

void TextToSpeechSetTablePath(char* pTablePath)
{
#ifdef OS_SYMBIAN
	FTTSDTUDATA_T* gpDECtalkUserData = GetGlobalDTPtr()->gpDECtalkUserData;
#else
	gpDECtalkUserData = &gDECtalkUserData;
#endif

	if(pTablePath)
	{
		FNX_STRCPY((char*)(gpDECtalkUserData->gDECtalkTablePath), pTablePath);
	}
	else
	{
		FNX_STRCPY((char*)(gpDECtalkUserData->gDECtalkTablePath), "");
	}
}
int FnxTTSDtSimpleSetLanguageW( FnxDECtalkLanguageId LanguageID, void *user_dict, wchar_t *dictname,wchar_t *tablename )
{
	char sdictname[256];
	char stablename[256];

	wcstombs(sdictname,dictname,128);// MAX_CHARS_TO_CONVERT);
	wcstombs(stablename, tablename,128);// MAX_CHARS_TO_CONVERT);

	return(FnxTTSDtSimpleSetLanguage(LanguageID,user_dict, sdictname,stablename ));

}
#ifdef OS_SYMBIAN
/*******************************************************************************
int FnxTTSDtSimpleCallback(short *output_buf,long error)
intilizes the TTS
Accepts a pointer to a array of 'short' and a 'long' error / status flag
     (size is 71 for 11Khz samplerate or 51 for 8Khz)
Returns a pointer to a buffer of shorts to receive the next data generated by 
the engine.  Returning a NULL for the buffer aborts the current synthesis 
operation
*******************************************************************************/
short *FnxTTSDTSimpleCollectCallback(short *output_buf,long error, void* pUserData)
{
  int reqLength = 0;
  GlobalDTPtr vgp = GetGlobalDTPtr();
  FTTSDTUDATA_T* gpDECtalkUserData = vgp->gpDECtalkUserData;

  switch (error)
  {
  	case 0: // NO ERROR
	  // Calculate the required buffer length to contain the next buffer
		if (gpDECtalkUserData->gDECtalkFlags > 2)
		  return(NULL);

		// Increment the buffer position pointer
		gpDECtalkUserData->gDECtalkBufPos += 
			gpDECtalkUserData->gDECtalkPktSize[gpDECtalkUserData->gDECtalkFlags];
	
		// See if the buffer has enough room for the next buffer
		reqLength = gpDECtalkUserData->gDECtalkBufPos + gpDECtalkUserData->gDECtalkPktSize[gpDECtalkUserData->gDECtalkFlags];
		if (reqLength > gpDECtalkUserData->gDECtalkBufSize)
		  {
			// if it doesn't call the user callback and then
			// reset the index
			gpDECtalkUserData->gDECtalkBufPtr = vgp->simpleData.g_usercallback((short*)gpDECtalkUserData->gDECtalkBufPtr, error, pUserData);
			gpDECtalkUserData->gDECtalkBufPos = 0;
		  }
	
		return((short *)(gpDECtalkUserData->gDECtalkBufPtr + gpDECtalkUserData->gDECtalkBufPos));
		break;
	case 3: // Index ??? What does this mean??
		gpDECtalkUserData->gDECtalkLastIndex[0] = (short)*(output_buf);
		gpDECtalkUserData->gDECtalkLastIndex[1] = (short)*(output_buf+1);
		return((short *)(gpDECtalkUserData->gDECtalkBufPtr + gpDECtalkUserData->gDECtalkBufPos));
		break;
	default:
		return (NULL);
		break;
  }
}

int FnxTTSDtSimpleGetSpeechData(short* buffer, int buflength )
{
	GlobalDTPtr vgp = GetGlobalDTPtr();
	int total_copied = 0;
	vgp->queueStruct.bufSize = buflength;

	total_copied = GetSpeechData(buffer, buflength);
	return total_copied;
}

const void* FnxTTSDtSimpleGetThreadData()
{
	return GetThreadData();
}
#endif

#if defined(__cplusplus)
}
#endif
